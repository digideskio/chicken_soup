######################################################################
#                             NGINX TASKS                            #
######################################################################
Capistrano::Configuration.instance(:must_exist).load do
  on        :start,                       'nginx:environment_detection'

  run_task  'web_server:stop',            :as => manager_username
  run_task  'web_server:start',           :as => manager_username
  run_task  'web_server:restart',         :as => manager_username

  run_task  'website:install',            :as => manager_username
  run_task  'website:remove',             :as => manager_username
  run_task  'website:enable',             :as => manager_username
  run_task  'website:disable',            :as => manager_username

  namespace :deploy do
    namespace :web do
      desc <<-DESC
        Enables the website's application by removing the maintenance page.
      DESC
      task :enable do
        website.maintenance_mode.disable
      end

      desc <<-DESC
        Disables the website's application by installing the maintenance page.
      DESC
      task :disable do
        website.maintenance_mode.enable
      end
    end
  end

  namespace :web_server do
    desc "Stop Apache"
    task :stop do
      nginx.stop
    end

    desc "Start Apache"
    task :start do
      nginx.start
    end

    desc "Restart Apache"
    task :restart do
      nginx.restart
    end
  end

  namespace :website do
    desc "Creates the site configuration for the files."
    task :create do
      nginx.virtual_host.install
    end

    desc "Completely removes the site configuration from the server (but leaves the files.)"
    task :remove do
      nginx.virtual_host.remove
    end

    desc "Enable Site"
    task :enable do
      nginx.website.enable
    end

    desc "Disable Site"
    task :disable do
      nginx.website.disable
    end

    namespace :maintenance_mode do
      desc <<-DESC
        Makes the application web-accessible again. Removes the \
        "maintenance.html" page generated by deploy:web:disable, which (if your \
        web servers are configured correctly) will make your application \
        web-accessible again.
      DESC
      task :disable, :except => { :no_release => true } do
        run "rm #{shared_path}/system/maintenance.html"
      end

      desc <<-DESC
        Present a maintenance page to visitors. Disables your application's web \
        interface by writing a "maintenance.html" file to each web server. The \
        servers must be configured to detect the presence of this file, and if \
        it is present, always display it instead of performing the request.

        By default, the maintenance page will just say the site is down for \
        "maintenance", and will be back "shortly", but you can customize the \
        page by specifying the REASON and UNTIL environment variables:

          $ cap deploy:web:disable \\
                REASON="hardware upgrade" \\
                UNTIL="12pm Central Time"

        Further customization will require that you write your own task.
      DESC
      task :enable, :except => { :no_release => true } do
        on_rollback { rm "#{shared_path}/system/maintenance.html" }

        require 'erb'
        deadline, reason = ENV['UNTIL'], ENV['REASON']

        template = File.read("./public/maintenance.html.erb")
        maintenance_page = ERB.new(template).result(binding)

        put maintenance_page, "#{shared_path}/system/maintenance.html", :mode => 0644
      end
    end
  end

  namespace :nginx do
    desc "[internal] Checks to see what type of Apache installation is running on the remote."
    task :environment_detection do
      find_nginx_control_script
    end

    desc "[internal] Starts the Nginx webserver"
    task :start do
      run "#{sudo} #{nginx_control_script} start"
    end

    desc "[internal] Stops the Nginx webserver"
    task :stop do
      run "#{sudo} #{nginx_control_script} stop"
    end

    desc "[internal] Stops the Nginx webserver"
    task :restart do
      run "#{sudo} #{nginx_control_script} restart"
    end

    desc "[internal] Reloads the Nginx configurations."
    task :reload do
      run "#{sudo} #{nginx_control_script} reload"
    end

    namespace :website do
      desc "[internal] Enables the Nginx site on the server level."
      task :enable do
        abort "Sorry, auto-enabling sites is not supported on your installation of Nginx." unless exists?(:nginx_enable_script)
      end

      desc "[internal] Disables the Apache site on the server level."
      task :disable do
        abort "Sorry, auto-disabling sites is not supported on your installation of Nginx." unless exists?(:nginx_disable_script)
      end
    end

    namespace :virtual_host do
      desc "[internal] Install Virtual Host"
      task :install do
        abort "Sorry, auto-installing sites is not supported on your installation of Nginx." unless exists?(:nginx_disable_script)

        passenger_friendly_error_messages = rails_env == :production ? "off" : "on"

        virtual_host_config = <<-VHOST
          server {
              listen                          #{web_server_ip}:443;
              server_name                     #{deploy_site_name} *.#{deploy_site_name};

              passenger_enabled               on;
              passenger_friendly_error_pages  #{passenger_friendly_error_pages};
              passenger_min_instances         4;

              rails_env                       #{rails_env};
              rack_env                        #{rails_env};

              ssl                             on;
              ssl_certificate                 /etc/nginx/ssl/#{domain}.crt;
              ssl_certificate_key             /etc/nginx/ssl/#{domain}.key;

              ssl_session_timeout             5m;

              ssl_ciphers                     ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;
              ssl_prefer_server_ciphers       on;

              root                            #{deploy_to}/current/public;

              client_max_body_size            3M;

              access_log                      /var/log/nginx/#{application}.access.log main;
              error_log                       /var/log/nginx/#{application}.error.log warn;

              error_page                      500 501 504 505 506 507 508 509 /500.html;
              error_page                      400 401 403 404 405 406 407 409 410 413 415 416 417 /404.html;
              error_page                      422 444 /422.html;
              error_page                      502 503 /public/maintenance.html;

              location / {
                try_files /system/maintenance.html $request_uri;
              }
          }

          server {
              listen                          #{web_server_ip}:80;
              server_name                     #{deploy_site_name} *.#{deploy_site_name};

              location / {
                rewrite ^ https://$http_host$request_uri? permanent
              }
          }
        VHOST

        put virtual_host_config, "#{user_home}/#{deploy_site_name}"
        run "#{sudo} mv #{user_home}/#{deploy_site_name} /etc/nginx/sites-available"
        run "#{sudo} /etc/init.d/nginx reload"
      end

      desc "[internal] Remove Virtual Host"
      task :remove do
        abort "Sorry, auto-removing sites is not supported on your installation of Nginx." unless exists?(:nginx_disable_script)

        run "#{sudo} rm /etc/nginx/sites-available/#{deploy_site_name}"
        run "#{sudo} #{nginx_control_script} reload"
      end
    end
  end
end

def find_nginx_control_script
  if remote_file_exists?("/etc/init.d/nginx")
    set :nginx_control_script,   "/etc/init.d/nginx"
  end

  abort "Couldn't figure out how to control your installation of Nginx" unless exists?(:nginx_control_script)
end
